<!doctype html>
<html>
   <body>
      <canvas width = "570" height = "570" id = "my_Canvas"></canvas>

      <script>
       
         var canvas = document.getElementById('my_Canvas');
         gl = canvas.getContext('experimental-webgl');

         document.addEventListener('click', () => {
            canvas.requestPointerLock = canvas.requestPointerLock || 
                                     canvas.mozRequestPointerLock || 
                                     canvas.webkitRequestPointerLock;
            canvas.requestPointerLock();
        });

        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === canvas) {
               mouseX = e.movementX;
               mouseY = e.movementY;
               rotateX(modelMatrix, mouseX*0.01)
               rotateY(modelMatrix, mouseY*0.01)
              // xAngle += mouseX*0.1;
              // yAngle += mouseY*0.1;
            }
        });




         var vertices = [
         -1, -1, -1,   
         1, -1, -1,   
         1,  1, -1,   
         1,  1, -1,   
        -1,  1, -1,   
        -1, -1, -1,   

        -1, -1,  1,   
         1, -1,  1,   
         1,  1,  1,   
         1,  1,  1,   
        -1,  1,  1,   
        -1, -1,  1,   

        -1,  1,  1,   
        -1,  1, -1,   
        -1, -1, -1,   
        -1, -1, -1,   
        -1, -1,  1,   
        -1,  1,  1,   

         1,  1,  1,   
         1,  1, -1,   
         1, -1, -1,   
         1, -1, -1,   
         1, -1,  1,   
         1,  1,  1,   

        -1, -1, -1,   
         1, -1, -1,   
         1, -1,  1,   
         1, -1,  1,   
        -1, -1,  1,   
        -1, -1, -1,   

        -1,  1, -1,   
         1,  1, -1,   
         1,  1,  1,   
         1,  1,  1,   
        -1,  1,  1,   
        -1,  1, -1  
         ];
         
         

         var vertex_buffer = gl.createBuffer();


         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
         
  
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);


         gl.bindBuffer(gl.ARRAY_BUFFER, null);

         var vertCode =
            'attribute vec3 coordinates;' +
            'uniform mat4 projection;'+
            'uniform mat4 view;'+
            'uniform mat4 model;'+
            'void main(void) {' +
               ' gl_Position = projection*view*model*vec4(coordinates, 1.0);' +
            '}';
            
 
         var vertShader = gl.createShader(gl.VERTEX_SHADER);

         gl.shaderSource(vertShader, vertCode);


         gl.compileShader(vertShader);


         var fragCode =
            'void main(void) {' +
               ' gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);' +
            '}';
            

         var fragShader = gl.createShader(gl.FRAGMENT_SHADER);


         gl.shaderSource(fragShader, fragCode); 
         

         gl.compileShader(fragShader);


         var shaderProgram = gl.createProgram();


         gl.attachShader(shaderProgram, vertShader);

         gl.attachShader(shaderProgram, fragShader);


         gl.linkProgram(shaderProgram);


         var pLoc = gl.getUniformLocation(shaderProgram, "projection");
         var vLoc = gl.getUniformLocation(shaderProgram, "view");
         var mLoc = gl.getUniformLocation(shaderProgram, "model");


         gl.useProgram(shaderProgram);


         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);


         

         var coord = gl.getAttribLocation(shaderProgram, "coordinates");


         gl.vertexAttribPointer(coord, 3, gl.FLOAT, false, 0, 0); 
         

         gl.enableVertexAttribArray(coord);



         var ang = Math.tan((40*0.5)*Math.PI/180);
         var projMatrix = [0.5/ang, 0 , 0, 0,
                           0, 0.5*(canvas.width/canvas.height)/ang, 0, 0,
                           0, 0, -(100+1)/(100-1), -1,
                           0, 0, (-2*100*1)/(100-1), 0 
                        ];
         var viewMatrix = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];
         var modelMatrix = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];

         viewMatrix[14] = viewMatrix[14]-6;


         function rotateZ(m, angle) {
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var mv0 = m[0], mv4 = m[4], mv8 = m[8];

            m[0] = c*m[0]-s*m[1];
            m[4] = c*m[4]-s*m[5];
            m[8] = c*m[8]-s*m[9];

            m[1]=c*m[1]+s*mv0;
            m[5]=c*m[5]+s*mv4;
            m[9]=c*m[9]+s*mv8;
         }

         function rotateY(m, angle) {
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var mv1 = m[1], mv5 = m[5], mv9 = m[9];

            m[1] = m[1]*c-m[2]*s;
            m[5] = m[5]*c-m[6]*s;
            m[9] = m[9]*c-m[10]*s;

            m[2] = m[2]*c+mv1*s;
            m[6] = m[6]*c+mv5*s;
            m[10] = m[10]*c+mv9*s;
         }

         function rotateX(m, angle) {
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var mv0 = m[0], mv4 = m[4], mv8 = m[8];

            m[0] = c*m[0]+s*m[2];
            m[4] = c*m[4]+s*m[6];
            m[8] = c*m[8]+s*m[10];

            m[2] = c*m[2]-s*mv0;
            m[6] = c*m[6]-s*mv4;
            m[10] = c*m[10]-s*mv8;
         }

         function lookAtWithAngles(cameraPos, xAngle, yAngle, up = [0, 1, 0]) {
            // Calculate front vector from angles
            const front = [
               Math.cos(yAngle) * Math.cos(xAngle),
               Math.sin(xAngle),
               Math.sin(yAngle) * Math.cos(xAngle)
            ];
            
            // Normalize front vector
            const frontNorm = normalize(front);
            
            // Calculate right vector
            const right = normalize(crossProduct(up, frontNorm));
            
            // Recalculate up vector to ensure orthogonality
            const upNorm = normalize(crossProduct(frontNorm, right));
            
            // Create view matrix
            return [
               [right[0], upNorm[0], -frontNorm[0], 0],
               [right[1], upNorm[1], -frontNorm[1], 0],
               [right[2], upNorm[2], -frontNorm[2], 0],
               [-dotProduct(right, cameraPos), -dotProduct(upNorm, cameraPos), dotProduct(frontNorm, cameraPos), 1]
            ];
         }

         // Helper functions (same as before)
         function normalize(v) {
            const length = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
            return [v[0] / length, v[1] / length, v[2] / length];
         }

         function crossProduct(a, b) {
            return [
               a[1] * b[2] - a[2] * b[1],
               a[2] * b[0] - a[0] * b[2],
               a[0] * b[1] - a[1] * b[0]
            ];
         }

         function dotProduct(a, b) {
            return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
         }


         var time = 0.1;

         gl.viewport(0,0,canvas.width,canvas.height);
/*
         document.addEventListener('keyup', (event) => {
            if (event.key == 'ArrowLeft') {
               rotateX(modelMatrix, 2*Math.PI-time*0.3);
            }
            if (event.key == 'ArrowDown') {
               rotateY(modelMatrix, time*0.3);
            }
            if (event.key == 'ArrowRight') {
               rotateX(modelMatrix, time*0.3);
            }
            if (event.key == 'ArrowUp') {
               rotateY(modelMatrix, 2*Math.PI-time*0.3);
            }
         });//*/

         let cameraPos = [0, 0, 3];      // Camera position
         let xAngle = 0;               // Pitch (up/down) in radians
         let yAngle = 0;   

         function gameloop() {

         gl.clearColor(0.5, 0.5, 0.5, 0.9);

         gl.enable(gl.DEPTH_TEST);


         gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

         /*
         let viewMatrix = lookAtWithAngles(cameraPos, xAngle, yAngle);

         // For WebGL, flatten the matrix
         let flatViewMatrix = new Float32Array([
            viewMatrix[0][0], viewMatrix[1][0], viewMatrix[2][0], viewMatrix[3][0],
            viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1], viewMatrix[3][1],
            viewMatrix[0][2], viewMatrix[1][2], viewMatrix[2][2], viewMatrix[3][2],
            viewMatrix[0][3], viewMatrix[1][3], viewMatrix[2][3], viewMatrix[3][3]
         ]);
         //*/
        

        // time += 0.001;
         //rotateZ(modelMatrix, time*0.5);
        // rotateY(modelMatrix, time*0.2);
        // rotateX(modelMatrix, time*0.3);


         gl.uniformMatrix4fv(pLoc, false, projMatrix);
         gl.uniformMatrix4fv(vLoc, false, viewMatrix);
         gl.uniformMatrix4fv(mLoc, false, modelMatrix);

         gl.drawArrays(gl.TRIANGLES, 0, 36);
         }

         setInterval(gameloop, 1000 / 30);
      </script>
    </body>
</html>